# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_pywrap_tensorflow', [dirname(__file__)])
        except ImportError:
            import _pywrap_tensorflow
            return _pywrap_tensorflow
        if fp is not None:
            try:
                _mod = imp.load_module('_pywrap_tensorflow', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _pywrap_tensorflow = swig_import_helper()
    del swig_import_helper
else:
    import _pywrap_tensorflow
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0



def IsGoogleCudaEnabled():
  return _pywrap_tensorflow.IsGoogleCudaEnabled()
IsGoogleCudaEnabled = _pywrap_tensorflow.IsGoogleCudaEnabled
class Status(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Status, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Status, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pywrap_tensorflow.delete_Status
    __del__ = lambda self : None;
    def __init__(self, *args): 
        this = _pywrap_tensorflow.new_Status(*args)
        try: self.this.append(this)
        except: self.this = this
    def ok(self): return _pywrap_tensorflow.Status_ok(self)
    def code(self): return _pywrap_tensorflow.Status_code(self)
    def error_message(self): return _pywrap_tensorflow.Status_error_message(self)
    def __eq__(self, *args): return _pywrap_tensorflow.Status___eq__(self, *args)
    def __ne__(self, *args): return _pywrap_tensorflow.Status___ne__(self, *args)
    def __str__(self): return _pywrap_tensorflow.Status___str__(self)
Status_swigregister = _pywrap_tensorflow.Status_swigregister
Status_swigregister(Status)


def __lshift__(*args):
  return _pywrap_tensorflow.__lshift__(*args)
__lshift__ = _pywrap_tensorflow.__lshift__

def NotOkay():
  return _pywrap_tensorflow.NotOkay()
NotOkay = _pywrap_tensorflow.NotOkay

def Okay():
  return _pywrap_tensorflow.Okay()
Okay = _pywrap_tensorflow.Okay
class PyRecordReader(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PyRecordReader, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PyRecordReader, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_getmethods__["New"] = lambda x: _pywrap_tensorflow.PyRecordReader_New
    if _newclass:New = staticmethod(_pywrap_tensorflow.PyRecordReader_New)
    __swig_destroy__ = _pywrap_tensorflow.delete_PyRecordReader
    __del__ = lambda self : None;
    def GetNext(self): return _pywrap_tensorflow.PyRecordReader_GetNext(self)
    def record(self): return _pywrap_tensorflow.PyRecordReader_record(self)
    def offset(self): return _pywrap_tensorflow.PyRecordReader_offset(self)
    def Close(self): return _pywrap_tensorflow.PyRecordReader_Close(self)
PyRecordReader_swigregister = _pywrap_tensorflow.PyRecordReader_swigregister
PyRecordReader_swigregister(PyRecordReader)

def PyRecordReader_New(*args):
  return _pywrap_tensorflow.PyRecordReader_New(*args)
PyRecordReader_New = _pywrap_tensorflow.PyRecordReader_New

class PyRecordWriter(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PyRecordWriter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PyRecordWriter, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_getmethods__["New"] = lambda x: _pywrap_tensorflow.PyRecordWriter_New
    if _newclass:New = staticmethod(_pywrap_tensorflow.PyRecordWriter_New)
    __swig_destroy__ = _pywrap_tensorflow.delete_PyRecordWriter
    __del__ = lambda self : None;
    def WriteRecord(self, *args): return _pywrap_tensorflow.PyRecordWriter_WriteRecord(self, *args)
    def Close(self): return _pywrap_tensorflow.PyRecordWriter_Close(self)
PyRecordWriter_swigregister = _pywrap_tensorflow.PyRecordWriter_swigregister
PyRecordWriter_swigregister(PyRecordWriter)

def PyRecordWriter_New(*args):
  return _pywrap_tensorflow.PyRecordWriter_New(*args)
PyRecordWriter_New = _pywrap_tensorflow.PyRecordWriter_New

class EventsWriter(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EventsWriter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EventsWriter, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _pywrap_tensorflow.new_EventsWriter(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pywrap_tensorflow.delete_EventsWriter
    __del__ = lambda self : None;
    def FileName(self): return _pywrap_tensorflow.EventsWriter_FileName(self)
    def _WriteSerializedEvent(self, *args): return _pywrap_tensorflow.EventsWriter__WriteSerializedEvent(self, *args)
    def Flush(self): return _pywrap_tensorflow.EventsWriter_Flush(self)
    def Close(self): return _pywrap_tensorflow.EventsWriter_Close(self)
    def WriteEvent(self, event):
      from tensorflow.core.util.event_pb2 import Event
      if not isinstance(event, Event):
        raise TypeError("Expected an event_pb2.Event proto, "
                        " but got %s" % type(event))
      return self._WriteSerializedEvent(event.SerializeToString())

EventsWriter_swigregister = _pywrap_tensorflow.EventsWriter_swigregister
EventsWriter_swigregister(EventsWriter)


def TF_NewStatus():
  return _pywrap_tensorflow.TF_NewStatus()
TF_NewStatus = _pywrap_tensorflow.TF_NewStatus

def TF_DeleteStatus(*args):
  return _pywrap_tensorflow.TF_DeleteStatus(*args)
TF_DeleteStatus = _pywrap_tensorflow.TF_DeleteStatus

def TF_GetCode(*args):
  return _pywrap_tensorflow.TF_GetCode(*args)
TF_GetCode = _pywrap_tensorflow.TF_GetCode

def TF_Message(*args):
  return _pywrap_tensorflow.TF_Message(*args)
TF_Message = _pywrap_tensorflow.TF_Message

def _TF_NewSessionOptions():
  return _pywrap_tensorflow._TF_NewSessionOptions()
_TF_NewSessionOptions = _pywrap_tensorflow._TF_NewSessionOptions

def _TF_SetTarget(*args):
  return _pywrap_tensorflow._TF_SetTarget(*args)
_TF_SetTarget = _pywrap_tensorflow._TF_SetTarget

def _TF_SetConfig(*args):
  return _pywrap_tensorflow._TF_SetConfig(*args)
_TF_SetConfig = _pywrap_tensorflow._TF_SetConfig

def TF_DeleteSessionOptions(*args):
  return _pywrap_tensorflow.TF_DeleteSessionOptions(*args)
TF_DeleteSessionOptions = _pywrap_tensorflow.TF_DeleteSessionOptions

def TF_NewSession(*args):
  return _pywrap_tensorflow.TF_NewSession(*args)
TF_NewSession = _pywrap_tensorflow.TF_NewSession

def TF_CloseSession(*args):
  return _pywrap_tensorflow.TF_CloseSession(*args)
TF_CloseSession = _pywrap_tensorflow.TF_CloseSession

def TF_DeleteSession(*args):
  return _pywrap_tensorflow.TF_DeleteSession(*args)
TF_DeleteSession = _pywrap_tensorflow.TF_DeleteSession

def TF_ExtendGraph(*args):
  return _pywrap_tensorflow.TF_ExtendGraph(*args)
TF_ExtendGraph = _pywrap_tensorflow.TF_ExtendGraph
def TF_NewSessionOptions(target=None, config=None):
  opts = _TF_NewSessionOptions()
  if target is not None:
    _TF_SetTarget(opts, target)
  if config is not None:
    from tensorflow.core.framework import config_pb2
    if not isinstance(config, config_pb2.ConfigProto):
      raise TypeError("Expected config_pb2.ConfigProto, "
                      "but got %s" % type(config))
    status = TF_NewStatus()
    config_str = config.SerializeToString()
    _TF_SetConfig(opts, config_str, len(config_str), status)
    if TF_GetCode(status) != 0:
      raise ValueError(TF_Message(status))
  return opts


def TF_Run(*args):
  return _pywrap_tensorflow.TF_Run(*args)
TF_Run = _pywrap_tensorflow.TF_Run
# This file is compatible with both classic and new-style classes.


